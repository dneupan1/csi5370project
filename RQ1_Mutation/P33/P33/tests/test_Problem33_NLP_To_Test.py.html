<html><body><h1>..\P33\.\tests\test_Problem33_NLP_To_Test.py</h1>Killed 11 out of 25 mutants<h2>Survived</h2>Survived mutation testing. These mutants show holes in your test suite.<h3>Mutant 149</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -1,7 +1,7 @@
 import pytest
 from Problem33_GeneratedSolution import rob_linear as rob_circular_houses  # Assuming the function 'rob_circular_houses' is in 'solution.py'
 
-@pytest.mark.parametrize("nums, expected", [
+@pytest.mark.parametrize("XXnums, expectedXX", [
     #([2, 3, 2], 3),  # Example 1: Small circular array with adjacency constraints
     ([1, 2, 3, 1], 4),  # Example 2: Circular array with optimal non-adjacent selection
     #([1, 2, 3], 3),  # Example 3: Optimal to choose the maximum single value
</pre><h3>Mutant 151</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -3,7 +3,7 @@
 
 @pytest.mark.parametrize("nums, expected", [
     #([2, 3, 2], 3),  # Example 1: Small circular array with adjacency constraints
-    ([1, 2, 3, 1], 4),  # Example 2: Circular array with optimal non-adjacent selection
+    ([1, 3, 3, 1], 4),  # Example 2: Circular array with optimal non-adjacent selection
     #([1, 2, 3], 3),  # Example 3: Optimal to choose the maximum single value
     ([], 0),  # Edge case: No houses, no money
     ([1], 1),  # Single house, only one choice available
</pre><h3>Mutant 153</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -3,7 +3,7 @@
 
 @pytest.mark.parametrize("nums, expected", [
     #([2, 3, 2], 3),  # Example 1: Small circular array with adjacency constraints
-    ([1, 2, 3, 1], 4),  # Example 2: Circular array with optimal non-adjacent selection
+    ([1, 2, 3, 2], 4),  # Example 2: Circular array with optimal non-adjacent selection
     #([1, 2, 3], 3),  # Example 3: Optimal to choose the maximum single value
     ([], 0),  # Edge case: No houses, no money
     ([1], 1),  # Single house, only one choice available
</pre><h3>Mutant 159</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -7,7 +7,7 @@
     #([1, 2, 3], 3),  # Example 3: Optimal to choose the maximum single value
     ([], 0),  # Edge case: No houses, no money
     ([1], 1),  # Single house, only one choice available
-    ([5, 1, 1, 5], 10),  # Circular array with large values non-adjacent
+    ([5, 2, 1, 5], 10),  # Circular array with large values non-adjacent
     #([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 16),  # Larger array, multiple optimal subproblems
     ([100], 100),  # Single large value
     #([5, 5, 5, 5, 5, 5, 5, 5, 5, 100], 260),  # Max value at end with equal small values around
</pre><h3>Mutant 160</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -7,7 +7,7 @@
     #([1, 2, 3], 3),  # Example 3: Optimal to choose the maximum single value
     ([], 0),  # Edge case: No houses, no money
     ([1], 1),  # Single house, only one choice available
-    ([5, 1, 1, 5], 10),  # Circular array with large values non-adjacent
+    ([5, 1, 2, 5], 10),  # Circular array with large values non-adjacent
     #([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 16),  # Larger array, multiple optimal subproblems
     ([100], 100),  # Single large value
     #([5, 5, 5, 5, 5, 5, 5, 5, 5, 100], 260),  # Max value at end with equal small values around
</pre><h3>Mutant 165</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -11,7 +11,7 @@
     #([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 16),  # Larger array, multiple optimal subproblems
     ([100], 100),  # Single large value
     #([5, 5, 5, 5, 5, 5, 5, 5, 5, 100], 260),  # Max value at end with equal small values around
-    ([3, 10, 3, 1, 2], 12)  # Complex small array, best option includes first and last values indirectly
+    ([4, 10, 3, 1, 2], 12)  # Complex small array, best option includes first and last values indirectly
 ])
 def test_rob_circular_houses(nums, expected):
     """
</pre><h3>Mutant 167</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -11,7 +11,7 @@
     #([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 16),  # Larger array, multiple optimal subproblems
     ([100], 100),  # Single large value
     #([5, 5, 5, 5, 5, 5, 5, 5, 5, 100], 260),  # Max value at end with equal small values around
-    ([3, 10, 3, 1, 2], 12)  # Complex small array, best option includes first and last values indirectly
+    ([3, 10, 4, 1, 2], 12)  # Complex small array, best option includes first and last values indirectly
 ])
 def test_rob_circular_houses(nums, expected):
     """
</pre><h3>Mutant 168</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -11,7 +11,7 @@
     #([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 16),  # Larger array, multiple optimal subproblems
     ([100], 100),  # Single large value
     #([5, 5, 5, 5, 5, 5, 5, 5, 5, 100], 260),  # Max value at end with equal small values around
-    ([3, 10, 3, 1, 2], 12)  # Complex small array, best option includes first and last values indirectly
+    ([3, 10, 3, 2, 2], 12)  # Complex small array, best option includes first and last values indirectly
 ])
 def test_rob_circular_houses(nums, expected):
     """
</pre><h3>Mutant 173</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -26,5 +26,5 @@
     nums (list of int): The amounts of money stashed in each house.
     expected (int): The expected maximum amount of money that can be robbed without alerting the police.
     """
-    assert rob_circular_houses(nums) == expected, f"Test failed for input {nums}. Expected {expected}, got {rob_circular_houses(nums)}"
+    assert rob_circular_houses(nums) == expected, f"XXTest failed for input {nums}. Expected {expected}, got {rob_circular_houses(nums)}XX"
 
</pre><h2>Suspicious</h2>Mutants that made the test suite take longer, but otherwise seemed ok<h3>Mutant 164</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -9,7 +9,7 @@
     ([1], 1),  # Single house, only one choice available
     ([5, 1, 1, 5], 10),  # Circular array with large values non-adjacent
     #([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 16),  # Larger array, multiple optimal subproblems
-    ([100], 100),  # Single large value
+    ([100], 101),  # Single large value
     #([5, 5, 5, 5, 5, 5, 5, 5, 5, 100], 260),  # Max value at end with equal small values around
     ([3, 10, 3, 1, 2], 12)  # Complex small array, best option includes first and last values indirectly
 ])
</pre><h3>Mutant 166</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -11,7 +11,7 @@
     #([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 16),  # Larger array, multiple optimal subproblems
     ([100], 100),  # Single large value
     #([5, 5, 5, 5, 5, 5, 5, 5, 5, 100], 260),  # Max value at end with equal small values around
-    ([3, 10, 3, 1, 2], 12)  # Complex small array, best option includes first and last values indirectly
+    ([3, 11, 3, 1, 2], 12)  # Complex small array, best option includes first and last values indirectly
 ])
 def test_rob_circular_houses(nums, expected):
     """
</pre><h3>Mutant 169</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -11,7 +11,7 @@
     #([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 16),  # Larger array, multiple optimal subproblems
     ([100], 100),  # Single large value
     #([5, 5, 5, 5, 5, 5, 5, 5, 5, 100], 260),  # Max value at end with equal small values around
-    ([3, 10, 3, 1, 2], 12)  # Complex small array, best option includes first and last values indirectly
+    ([3, 10, 3, 1, 3], 12)  # Complex small array, best option includes first and last values indirectly
 ])
 def test_rob_circular_houses(nums, expected):
     """
</pre><h3>Mutant 171</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -1,18 +1,6 @@
 import pytest
 from Problem33_GeneratedSolution import rob_linear as rob_circular_houses  # Assuming the function 'rob_circular_houses' is in 'solution.py'
 
-@pytest.mark.parametrize("nums, expected", [
-    #([2, 3, 2], 3),  # Example 1: Small circular array with adjacency constraints
-    ([1, 2, 3, 1], 4),  # Example 2: Circular array with optimal non-adjacent selection
-    #([1, 2, 3], 3),  # Example 3: Optimal to choose the maximum single value
-    ([], 0),  # Edge case: No houses, no money
-    ([1], 1),  # Single house, only one choice available
-    ([5, 1, 1, 5], 10),  # Circular array with large values non-adjacent
-    #([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], 16),  # Larger array, multiple optimal subproblems
-    ([100], 100),  # Single large value
-    #([5, 5, 5, 5, 5, 5, 5, 5, 5, 100], 260),  # Max value at end with equal small values around
-    ([3, 10, 3, 1, 2], 12)  # Complex small array, best option includes first and last values indirectly
-])
 def test_rob_circular_houses(nums, expected):
     """
     Tests the rob_circular_houses function with various configurations of house values to ensure it correctly calculates the maximum money that can be robbed without alerting the police.
</pre><h3>Mutant 172</h3><pre>--- ..\P33\.\tests\test_Problem33_NLP_To_Test.py
+++ ..\P33\.\tests\test_Problem33_NLP_To_Test.py
@@ -26,5 +26,5 @@
     nums (list of int): The amounts of money stashed in each house.
     expected (int): The expected maximum amount of money that can be robbed without alerting the police.
     """
-    assert rob_circular_houses(nums) == expected, f"Test failed for input {nums}. Expected {expected}, got {rob_circular_houses(nums)}"
+    assert rob_circular_houses(nums) != expected, f"Test failed for input {nums}. Expected {expected}, got {rob_circular_houses(nums)}"
 
</pre></body></html>